原码、反码、补码是计算机中用于表示有符号整数的二进制编码方式，主要应用于负数的处理。

### 原码、反码、补码的关系

1. **原码**（True Form）:
   - 原码直接使用二进制表示一个数，其中最高位作为符号位，0表示正数，1表示负数。其余位表示数值的绝对值。例如，+5的原码是00000101，而-5的原码是10000101。

2. **反码**（One's Complement）:
   - 正数的反码与原码相同。对于负数，反码是其原码除了符号位之外的所有位取反（0变为1，1变为0）。例如，-5的反码是11111010。

3. **补码**（Two's Complement）:
   - 正数的补码与原码相同。负数的补码是在其反码的基础上加1。补码的主要优点是使得加法和减法运算可以统一处理，包括正数加正数、负数加负数、正数加负数等所有情况。例如，-5的补码是11111011。

### C语言中的移位操作符

C语言提供了两个移位操作符：左移（<<）和右移（>>）。这些操作符用于对整数类型的变量进行位级别的操作。

- **左移（<<）**:
  当你对一个数进行左移操作时，相当于将其二进制表示向左移动指定的位数，并在右侧填充零。这等效于乘以2的指定次方。例如，`x << n` 将x的二进制表示向左移动n位。如果x是带符号的，那么它的补码会被移动，保持符号位不变。

- **右移（>>）**:
  右移操作符将一个数的二进制表示向右移动指定的位数。对于无符号数，右侧填充0；而对于有符号数，行为取决于编译器，但通常遵循以下原则：
  - **算术右移（Arithmetic Shift Right, ASR）**: 符号位保持不变，左侧填充该符号位的值。这意味着负数右移时会保持为负数，相当于除以2的n次方并向下取整。
  - **逻辑右移（Logical Shift Right, LSR）**: 不管原数是正是负，左侧都填充0。这种移位通常用于无符号数或不需要考虑符号的场合。

在大多数现代系统中，对于有符号整数，右移操作符执行的是算术右移，以保持符号的正确性。

### 示例

假设有一个带符号的8位整数（即int8_t），值为-5（补码为11111011）：

- 左移两位 `(-5 << 2)` 结果为 -20（补码11111100），这是因为-5相当于二进制的11111011，左移两位后填充0得到11111100。
- 右移一位 `(-5 >> 1)` 如果是算术右移，结果为-3（补码11111101），符号位保持不变，其他位向右移一位后填充符号位。

需要注意的是，移位操作的结果可能会受到整数溢出的影响，特别是当移位过多以至于影响到了符号位时。在实际编程中，需要留意移位操作可能导致的数值范围超界问题。
2*2*2*2*2*2*2=2^7=128